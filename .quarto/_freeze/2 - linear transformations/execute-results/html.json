{
  "hash": "a2d41ebabf56284f86a5179958e6349f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"1.2 - linear transformations\"\nformat: \n  revealjs:\n    slide-number: true\neditor_options: \n  chunk_output_type: console\n  mode: source\n---\n\n## Linear transformations of image data\n\n![](images/clipboard-1624064392.png)\n\n## Linear combinations and dot products {.smaller}\n\n-   A *linear combination* of a vector is simply a weighted sum of its coordinates\n\n-   Linear combinations are often represented by *dot products*\n\n-   The *dot product* of two $p-$dimensional vectors is a single number\n\n-   E.g., consider the dot product of $u = (3,1)$ with weighting vector $w = (-1, 4)$:\n\n. . .\n\n$$<u,w> = u \\cdot w = (3, 1) \\times \\begin{pmatrix} -1 \\\\ 4 \\end{pmatrix}$$\n\n. . .\n\n$$ = 3\\cdot -1 + 1\\cdot 4 = 1$$\n\n. . .\n\n-   Note that dot products require one vector written as a row and the other as a column vector.\n\n## Example: Kwik Trip {.smaller}\n\n-   At Kwik Trip, a corn dog costs \\$1.99; a milkshake costs \\$5.29, and a 9.9 oz bag of takis costs \\$5.29.\\\n-   You go to Kwik Trip and buy 2 corn dogs, a milkshake, and 5 bags of takis.\n-   How can you represent $C$, the total cost, as the dot product of two vectors? How would you define these vectors? What is $C$?\n\n$$u = ?$$ $$w = ?$$ $$C = <u,w> = ?$$\n\n## Example: linear regression {.smaller}\n\n-   In linear regression, we often represent fitted values as the dot product between and $x$ vector and a $\\hat\\beta$ vector.\n-   Suppose you've fit a linear regression model of house price on the size (in square meters) and number of bedrooms.\\\n-   You have the following output:\n\n``` r\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   55957.2    22896.1   2.443   0.0187 *  \nsize           989.4       195.6   5.056  2.04e-06 ***\nbedrooms     10291.9      3688.2   2.791   0.0076 ** \n```\n\n-   GOAL: predict the price of a home with 200 sq m and 3 bedrooms.\n-   This is the dot product $<x,\\hat\\beta>$ with:\n\n$$x = ?$$ $$\\hat\\beta = ?$$\n\n## Geometric interpretation {.smaller}\n\n-   The dot product of two $p$-dimensional vectors is a single number\n\n-   The sign of this number is related to the angle between the vectors:\n\n    ![](images/clipboard-4174632890.png){width=\"900\"}\n\n. . .\n\n$$<u,v> = 3\\cdot 1 + 1\\cdot 4 = 7 > 0$$\n\n. . .\n\n$$<u,w> = 3\\cdot -1 + 1 \\cdot 3 = 0$$\n\n. . .\n\n$$<u,x> = 3\\cdot -2 + 1 \\cdot -3 = -9 < 0$$\n\n## Geometric interpretation {.smaller}\n\nIt turns out:\n\n$$\n<u,v> = ||u||_2 ||v||_2 cos(\\theta)\n$$\n\nwhere $\\theta$ is the angle formed by $u$ and $v$:\n\n![](images/clipboard-3448825483.png){width=\"584\" fig-align=\"center\"}\n\nNote also: ***orthogonal*** (i.e., perpendicular) vectors have dot product = 0!\n\n## Linear transformations = Dot products by matrices\n\n-   The dot product of two $p-$dimensional vectors is always a single number, representing the angle between them.\n-   If a $p$-dimensional vector is dot-multiplied by a $p\\times m$ *matrix*, the result is a **linear transformation:** a mapping of $p$ dimensional space onto $m$ dimensional space.\n\n## Matrix multiplication: a refresher {.smaller}\n\nConsider the $2 \\times 2$ matrix $A = \\begin{pmatrix} 3 & 2 \\\\ 1 & 2 \\end{pmatrix}$ and 2-dimensional vector $u = (1,2)$.\n\nThen:\n\n$$Au = \\begin{pmatrix} 3 & 2 \\\\ 1 & 2 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$$\n\n. . .\n\n$$= \\begin{pmatrix} 3\\cdot 1 + 2\\cdot 2 \\\\ 1\\cdot 1 + 2\\cdot 2  \\end{pmatrix}$$\n\n. . .\n\n$$= \\begin{pmatrix} 7 \\\\ 5  \\end{pmatrix}$$\n\n. . .\n\nNote that we have *transformed* one 2-dimensional vector into another 2-dimensional vector!\n\n## Matrix multiplication dimensions\n\nWhen multiplying matrices $A$ ($n\\times p$) and $B$ ($p \\times m$):\n\n-   $ncol(A)$ must equal $nrow(B)$\n-   $AB$ has dimension $n \\times m$ = $nrow(A) \\times ncol(B)$\n\n## Matrix multiplication dimensions {.smaller auto-animate=\"true\"}\n\n-   Reconsider the $2\\times 2$ matrix $A = \\begin{pmatrix} 3 & 2 \\\\ 1 & 2 \\end{pmatrix}$ and vector $u = (1,2)$.\n-   To multiply $Au$, $u$ must be expressed as a $2 \\times 1$ matrix: $$\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$$\n-   Result of $Au$ is $2\\times 1$ ($ncol(A) \\times nrow(u)$)\n\n. . .\n\n-   To reverse order of multiplication, we would have to express $u$ as a row vector:\n\n$$u^T A = \\begin{pmatrix}1 & 2 \\end{pmatrix} \\begin{pmatrix} 3 & 2 \\\\ 1 & 2 \\end{pmatrix}$$\n\n. . .\n\n$$ = \\begin{pmatrix}1\\cdot 3 + 2\\cdot 1 & 2 \\cdot 2 + 2 \\cdot 2 \\end{pmatrix}$$\n\n. . .\n\n$$= \\begin{pmatrix} 5 & 8 \\end{pmatrix}$$\n\n## Linear transformation: a visual {.smaller}\n\n::: column\n-   In the following slides, let's consider a transformation of the $4 \\times 2$ matrix of row vectors:\n\n$$\\color{CornflowerBlue}{X = {\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 1 & 1 \\\\ 0 & 1 \\\\ \\end{pmatrix}}}$$\n\n-   Consider this a \"data frame\" of $n = 4$ rows and $p=2$ columns.\n\n-   We will apply the transformation matrix $A = \\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix}$.\n:::\n\n::: column\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-1-1.png){fig-align='center' width=480}\n:::\n:::\n\n:::\n\n## First row\n\n$$\\color{CornflowerBlue}{\\begin{pmatrix} 0 & 0 \\end{pmatrix}} \\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix}  = \\color{Orange}{\\begin{pmatrix} 0 & 0 \\end{pmatrix}}$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Second row\n\n$$\\color{CornflowerBlue}{\\begin{pmatrix} 1 & 0 \\end{pmatrix}} \n\\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix}  = \n\\color{Orange}{\\begin{pmatrix} 3 & 1 \\end{pmatrix}}$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Third row\n\n$$\\color{CornflowerBlue}{\\begin{pmatrix} 1 & 1 \\end{pmatrix}} \n\\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix}  = \n\\color{Orange}{\\begin{pmatrix} 5 & 3 \\end{pmatrix}}$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Fourth row\n\n$$\\color{CornflowerBlue}{\\begin{pmatrix} 0 & 1 \\end{pmatrix}} \n\\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix}  = \n\\color{Orange}{\\begin{pmatrix} 2 & 2 \\end{pmatrix}}$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Full transformation\n\n$$\\color{CornflowerBlue}{{\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 1 & 1 \\\\ 0 & 1 \\\\ \\end{pmatrix}}}\\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix} = \\color{Orange}{\\begin{pmatrix} 0 & 0 \\\\ 3 & 1 \\\\ 5 & 3 \\\\ 2 & 2 \\end{pmatrix}}$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-6-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n\n## Matrix algebra in `R` {auto-animate=\"true\"}\n\nTo form and multiply matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbluecoords <- matrix(c(0,0,\n              1,0,\n              1,1,\n              0,1),\n            nrow = 4, ncol = 2,\n            byrow = TRUE\n            )\n```\n:::\n\n\n## Matrix algebra in `R` {auto-animate=\"true\"}\n\nTo form and multiply matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbluecoords <- matrix(c(0,0,\n              1,0,\n              1,1,\n              0,1),\n            nrow = 4, ncol = 2,\n            byrow = TRUE\n            )\n\nA <- matrix(c(3, 1,\n              2, 2),\n            nrow = 2, ncol = 2,\n            byrow=TRUE\n            )\n```\n:::\n\n\n## Matrix algebra in `R` {auto-animate=\"true\"}\n\nTo form and multiply matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbluecoords <- matrix(c(0,0,\n              1,0,\n              1,1,\n              0,1),\n            nrow = 4, ncol = 2,\n            byrow = TRUE\n            )\n\nA <- matrix(c(3, 1,\n              2, 2),\n            nrow = 2, ncol = 2,\n            byrow=TRUE\n            )\nbluecoords %*% A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    0    0\n[2,]    3    1\n[3,]    5    3\n[4,]    2    2\n```\n\n\n:::\n:::\n\n\n## Identity matrix {.smaller}\n\n-   The *identity matrix* $I$ is the matrix equivalent of \"1\".\n-   Square $p\\times p$ matrix with 1's on the diagonal and 0's elsewhere:\n\n$$\nI = \\begin{pmatrix} 1 & 0 & \\dots & 0 \\\\ \n0 & 1 & \\dots& 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\dots & 1\n\\end{pmatrix}\n$$\n\n-   For any $n \\times p$ matrix $X$, $XI = X$.\n\n## Identity matrix\n\n$$\\color{CornflowerBlue}{{\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 1 & 1 \\\\ 0 & 1 \\\\ \\end{pmatrix}}}\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\color{CornflowerBlue}{\\begin{pmatrix}0 & 0 \\\\ 1 & 0 \\\\ 1 & 1 \\\\ 0 & 1 \\\\ \\end{pmatrix}}$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-10-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Matrix inverses: going backward {.smaller}\n\n::: {.column width=\"60%\"}\n-   $\\color{CornflowerBlue}{\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 1 & 1 \\\\ 0 & 1 \\\\ \\end{pmatrix}} \\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix} =  \\color{Orange}{\\begin{pmatrix} 0 & 0 \\\\ 3 & 1 \\\\ 5 & 3 \\\\ 2 & 2 \\end{pmatrix}}$\n\n-   $\\color{Orange}{\\begin{pmatrix} 0 & 0 \\\\ 3 & 1 \\\\ 5 & 3 \\\\ 2 & 2 \\end{pmatrix}} \\begin{pmatrix} 3 & 1 \\\\ 2 & 2 \\end{pmatrix}^{-1}= \\color{CornflowerBlue}{\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 1 & 1 \\\\ 0 & 1 \\\\ \\end{pmatrix}}$\n:::\n\n::: {.column width=\"40%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-11-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-12-1.png){fig-align='center' width=960}\n:::\n:::\n\n:::\n\n## What is an inverse?\n\nThe **inverse** of a square $p\\times p$ matrix $A$ is notated $A^{-1}$ and is the matrix such that:\n\n$$\nA A^{-1} =I\n$$\n\nwhere $I$ is the identity matrix.\n\n## Inverses in `R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAinverse <- solve(A)\nAinverse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]  [,2]\n[1,]  0.5 -0.25\n[2,] -0.5  0.75\n```\n\n\n:::\n:::\n\n\n## Inverses in `R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAinverse <- solve(A)\nAinverse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]  [,2]\n[1,]  0.5 -0.25\n[2,] -0.5  0.75\n```\n\n\n:::\n\n```{.r .cell-code}\norangecoords <- matrix(c(0,0,\n                         3,1,\n                         5,3,\n                         2,2),\n                       nrow = 4, ncol = 2,\n                       byrow = TRUE\n                       )\n```\n:::\n\n\n## Inverses in `R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAinverse <- solve(A)\nAinverse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]  [,2]\n[1,]  0.5 -0.25\n[2,] -0.5  0.75\n```\n\n\n:::\n\n```{.r .cell-code}\norangecoords <- matrix(c(0,0,\n                         3,1,\n                         5,3,\n                         2,2),\n                       nrow = 4, ncol = 2,\n                       byrow = TRUE\n                       )\n\nround(orangecoords %*% Ainverse,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    0    0\n[2,]    1    0\n[3,]    1    1\n[4,]    0    1\n```\n\n\n:::\n:::\n\n\n## Finding arbitrary transformation matrix {.smaller}\n\n::: column\n-   The matrix $A$ is often referred to as a *transformation matrix*\n-   It *transforms* the [blue]{style=\"color: cornflowerblue\"} coordinates into [orange]{style=\"color: orange\"} coordinates\n-   What if have the transformation, but we want to find a matrix? E.g., what matrix $B$ is such that $\\color{CornflowerBlue}{X}B = \\color{forestgreen}{W}$ with $\\color{forestgreen}{W = \\begin{pmatrix} 0 & 0 \\\\ 2 & -3 \\\\ 0 & -2 \\\\ -2 & 1 \\end{pmatrix}}$?\n:::\n\n::: column\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-16-1.png){fig-align='center' width=768}\n:::\n:::\n\n:::\n\n## Finding arbitrary transformation matrix\n\nWe can find $B$ (must be $2 \\times 2$) using some matrix algebra, given we know coordinates $\\color{CornflowerBlue}{X}$ ($4 \\times 2$) and $\\color{forestgreen}{W}$ ($4 \\times 2$):\n\n$$ \\color{CornflowerBlue}{X}B =\\color{forestgreen}{W}$$\n\n. . .\n\n$$ \\color{CornflowerBlue}{X^T}\\color{CornflowerBlue}{X}B =\\color{CornflowerBlue}{X^T}\\color{forestgreen}{W}$$\n\n. . .\n\n$$ \\left(\\color{CornflowerBlue}{X^T}\\color{CornflowerBlue}{X}\\right)^{-1}\\color{CornflowerBlue}{X^T}\\color{CornflowerBlue}{X}B = \\left(\\color{CornflowerBlue}{X^T}\\color{CornflowerBlue}{X}\\right)^{-1}\\color{CornflowerBlue}{X^T}\\color{forestgreen}{W}$$\n\n. . .\n\n$$ B = \\left(\\color{CornflowerBlue}{X^T}\\color{CornflowerBlue}{X}\\right)^{-1}\\color{CornflowerBlue}{X^T}\\color{forestgreen}{W}$$\n\n## Transforming [blue]{style=\"color: cornflowerblue\"} into [green]{style=\"color: forestgreen\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreencoords <- matrix(c(0,0,\n                        2,-3,\n                        0,-2,\n                        -2,1),\n                      nrow = 4, ncol = 2,\n                      byrow = TRUE\n                      )\nB <- solve(t(bluecoords)%*%bluecoords) %*% t(bluecoords) %*% greencoords\n\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2   -3\n[2,]   -2    1\n```\n\n\n:::\n\n```{.r .cell-code}\nbluecoords%*% B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    0    0\n[2,]    2   -3\n[3,]    0   -2\n[4,]   -2    1\n```\n\n\n:::\n:::\n\n\n## `ggplot` code {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(patchwork) #for adding plots side-by-side\n\nbluedf <- data.frame(bluecoords)\ngreendf <- data.frame(greencoords)\n\n\n# Create base\nbase <- ggplot() +\n  scale_x_continuous(breaks=seq(-5,5,by=1),limits=c(-5,5)) +\n    scale_y_continuous(breaks=seq(-5,5,by=1),limits=c(-5,5)) + \n  geom_vline(aes(xintercept = 0)) +  geom_hline(aes(yintercept = 0)) +  \n  theme_minimal(base_size = 14) + \n  theme(panel.grid.minor = element_blank()) + \n  labs(x='', y='')\n\n# Add points\nbluepoints <- base +  \n  geom_point(data = bluedf, aes(x = X1, y = X2), size = 3,col='cornflowerblue') \ngreenpoints <- base + \n  geom_point(data = df2, aes(x = X1, y = X2), size = 3,col='forestgreen')\np1 + p2\n```\n:::\n\n\n## Transformations commute!\n\nIf $A$ transforms [blue]{style=\"color: cornflowerblue\"} into [orange]{style=\"color: orange\"} and $B$ transforms [orange]{style=\"color: orange\"} into [green]{style=\"color: forestgreen\"}, then $AB$ transforms [blue]{style=\"color: cornflowerblue\"} into [green]{style=\"color: forestgreen\"}.\n\nSee activity!\n\n## Transformations don't have to be $p\\rightarrow p$ {.smaller}\n\n- In the examples we've considered so far, we've transformed 2-dimensional space to 2-dimensional space.\n- We don't have to go $p\\rightarrow p$: we can go $p\\rightarrow m$ with $m<p$, or $p\\rightarrow q$ with $q > p$.  \n- In this class, we will most frequently encounter *dimension reduction*: that is. transformations into *lower dimensional* space ($p \\rightarrow m$ with $m < p$).\n- There are 2 ways to \"transform down\":\n  - Use a lower dimensional transformation matrix;\n  - Use a rank deficient transformation matrix\n  \n## Lower dimension $A$ {.smaller}\n\n- The easiest way to transform down is to use a lower-dimension transformation matrix.\n\n- Consider 3-dimensional row vector $u = (-1, 3, 2)$ and $3 \\times 2$ transformation matrix $A = \\begin{pmatrix}3 & 2 \\\\ 1 & 1 \\\\ -1 & 4\\end{pmatrix}$  \n\n$$ u A = (-1, 3, 2)\\begin{pmatrix}3 & 2 \\\\ 1 & 1 \\\\ -1 & 4\\end{pmatrix}$$\n\n. . .\n\n$$= (-3+3-2 , -2+3+8)$$\n\n. . .\n\n$$ = (-2, 9)$$\n\nThus we have transformed the 3-dimensional $u$ into 2-dimensional space.\n\n## Rank deficient $A$ {.smaller}\n\n- In the previous example it was obvious that using a $3\\times 2$ matrix $A$ would transform 3-dimensional $u$ into 2 dimensions\n- But downward transformations can be more subtle!\n- Consider now:\n\n$$A = \\begin{pmatrix} 1 & 4 & 2 \\\\ 2 & 5 & 1 \\\\ 3 & 6 & 0 \\end{pmatrix}$$\n\n. . .\n\n$$u A = (-1, 3, 2)\\begin{pmatrix} 1 & 4 & 2 \\\\ 2 & 5 & 1 \\\\ 3 & 6 & 0 \\end{pmatrix}$$\n\n. . .\n\n$$ = (11, 23, 1)$$\n\n...so it *looks* like we've stayed in 3 dimensions!\n\n## Rank deficient $A$ \n\nBut let's see what happens if we do this to several $u$'s:\n\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1100)\nn <- 100\nUmatrix <- matrix(runif(3*n), \n                  nrow = n, \n                  ncol = 3)\nhead(Umatrix) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]       [,2]      [,3]\n[1,] 0.6550844 0.93924628 0.6369416\n[2,] 0.5774114 0.07323043 0.8723149\n[3,] 0.3938457 0.61220768 0.8475611\n[4,] 0.4048126 0.52145253 0.7292520\n[5,] 0.5263594 0.41795632 0.5186670\n[6,] 0.1073119 0.74717823 0.7474164\n```\n\n\n:::\n:::\n\n::: \n\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,4,2,\n              2,5,1,\n              3,6,0\n              ), \n            nrow = 3, ncol = 3, \n            byrow=TRUE\n            )\nUA <- Umatrix %*% A\nhead(UA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]      [,2]     [,3]\n[1,] 4.444402 11.138218 2.249415\n[2,] 3.340817  7.909687 1.228053\n[3,] 4.160944  9.721788 1.399899\n[4,] 3.635474  8.602025 1.331078\n[5,] 2.918273  7.307222 1.470675\n[6,] 3.843918  8.649637 0.961802\n```\n\n\n:::\n:::\n\n:::\n\n## Plotting $U$ and $UA$ {.smaller}\n\n::: column\n$U$ is truly 3D:\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"rgl97367\" style=\"width:400px;height:400px;\" class=\"rglWebGL html-widget \" role=\"img\" aria-labelledby=\"rgl97367-aria\"></div>\n<script type=\"application/json\" data-for=\"rgl97367\">{\"x\":{\"material\":{\"color\":\"#000000\",\"alpha\":1,\"lit\":true,\"ambient\":\"#000000\",\"specular\":\"#FFFFFF\",\"emission\":\"#000000\",\"shininess\":50,\"smooth\":true,\"front\":\"filled\",\"back\":\"filled\",\"size\":3,\"lwd\":1,\"fog\":true,\"point_antialias\":false,\"line_antialias\":false,\"texture\":null,\"textype\":\"rgb\",\"texmode\":\"modulate\",\"texmipmap\":false,\"texminfilter\":\"linear\",\"texmagfilter\":\"linear\",\"texenvmap\":false,\"depth_mask\":true,\"depth_test\":\"less\",\"isTransparent\":false,\"polygon_offset\":[0,0],\"margin\":\"\",\"floating\":false,\"tag\":\"\",\"blend\":[\"src_alpha\",\"one_minus_src_alpha\"]},\"rootSubscene\":6,\"objects\":{\"13\":{\"id\":13,\"type\":\"points\",\"material\":{\"lit\":false},\"vertices\":\"0\",\"colors\":\"1\",\"centers\":\"2\",\"ignoreExtent\":false,\"flags\":34816},\"15\":{\"id\":15,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":0,\"floating\":true,\"edge\":[0,1,1]},\"vertices\":\"3\",\"colors\":\"4\",\"texts\":[[\"x\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"5\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"16\":{\"id\":16,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":1,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"6\",\"colors\":\"7\",\"texts\":[[\"y\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"8\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"17\":{\"id\":17,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":2,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"9\",\"colors\":\"10\",\"texts\":[[\"z\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"11\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"10\":{\"id\":10,\"type\":\"light\",\"vertices\":[[0,0,1]],\"colors\":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],\"viewpoint\":true,\"finite\":false},\"12\":{\"id\":12,\"type\":\"background\",\"material\":{\"lit\":false,\"back\":\"lines\"},\"colors\":\"12\",\"centers\":\"13\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"14\":{\"id\":14,\"type\":\"bboxdeco\",\"material\":{\"front\":\"lines\",\"back\":\"lines\"},\"vertices\":\"14\",\"colors\":\"15\",\"axes\":{\"mode\":[\"pretty\",\"pretty\",\"pretty\"],\"step\":[0.2000000029802322,0.2000000029802322,0.2000000029802322],\"nticks\":[5,5,5],\"marklen\":[15,15,15],\"expand\":[1.029999971389771,1.029999971389771,1.029999971389771]},\"draw_front\":true,\"flags\":32769},\"6\":{\"id\":6,\"type\":\"subscene\",\"par3d\":{\"antialias\":8,\"FOV\":30,\"ignoreExtent\":false,\"listeners\":6,\"mouseMode\":{\"none\":\"none\",\"left\":\"trackball\",\"right\":\"zoom\",\"middle\":\"fov\",\"wheel\":\"pull\"},\"observer\":[0,0,4.167541027069092],\"modelMatrix\":[[1.010946154594421,0,0,-0.5105584263801575],[0,0.3418488800525665,0.9301901459693909,-0.636387825012207],[0,-0.9392220377922058,0.3385615348815918,-3.864412546157837],[0,0,0,1]],\"projMatrix\":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.86370325088501,-15.02350330352783],[0,0,-1,0]],\"skipRedraw\":false,\"userMatrix\":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],\"userProjection\":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],\"scale\":[1.010946154594421,0.9994992017745972,0.9898876547813416],\"viewport\":{\"x\":0,\"y\":0,\"width\":1,\"height\":1},\"zoom\":1,\"bbox\":[0.01870691776275635,0.9913536906242371,0.01086365152150393,0.9946498870849609,0.002713536145165563,0.996052086353302],\"windowRect\":[190,213,446,469],\"family\":\"sans\",\"font\":1,\"cex\":1,\"useFreeType\":false,\"fontname\":\"TT Arial\",\"maxClipPlanes\":8,\"glVersion\":4.6,\"activeSubscene\":0},\"embeddings\":{\"viewport\":\"replace\",\"projection\":\"replace\",\"model\":\"replace\",\"mouse\":\"replace\"},\"objects\":[12,14,13,15,16,17,10],\"subscenes\":[],\"flags\":36113}},\"crosstalk\":{\"key\":[],\"group\":[],\"id\":[],\"options\":[]},\"width\":400,\"height\":400,\"buffer\":{\"accessors\":[{\"bufferView\":0,\"componentType\":5126,\"count\":100,\"type\":\"VEC3\"},{\"bufferView\":1,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":2,\"componentType\":5126,\"count\":100,\"type\":\"VEC3\"},{\"bufferView\":3,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":4,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":5,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":6,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":7,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":8,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":9,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":10,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":11,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":12,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":13,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":14,\"componentType\":5126,\"count\":12,\"type\":\"VEC3\"},{\"bufferView\":15,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"}],\"bufferViews\":[{\"buffer\":0,\"byteLength\":1200,\"byteOffset\":0},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":1200},{\"buffer\":0,\"byteLength\":1200,\"byteOffset\":1204},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2404},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2416},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2420},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2432},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2444},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2448},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2460},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2472},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2476},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2488},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":2492},{\"buffer\":0,\"byteLength\":144,\"byteOffset\":2496},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2640}],\"buffers\":[{\"byteLength\":2644,\"bytes\":\"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\"}]},\"context\":{\"shiny\":false,\"rmarkdown\":null},\"vertexShader\":\"#line 2 1\\n// File 1 is the vertex shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\n\\nattribute vec3 aPos;\\nattribute vec4 aCol;\\nuniform mat4 mvMatrix;\\nuniform mat4 prMatrix;\\nvarying vec4 vCol;\\nvarying vec4 vPosition;\\n\\n#ifdef NEEDS_VNORMAL\\nattribute vec3 aNorm;\\nuniform mat4 normMatrix;\\nvarying vec4 vNormal;\\n#endif\\n\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nattribute vec2 aTexcoord;\\nvarying vec2 vTexcoord;\\n#endif\\n\\n#ifdef FIXED_SIZE\\nuniform vec3 textScale;\\n#endif\\n\\n#ifdef FIXED_QUADS\\nattribute vec3 aOfs;\\n#endif\\n\\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\nvarying float normz;\\nuniform mat4 invPrMatrix;\\n#else\\nattribute vec3 aPos1;\\nattribute vec3 aPos2;\\nvarying float normz;\\n#endif\\n#endif // IS_TWOSIDED\\n\\n#ifdef FAT_LINES\\nattribute vec3 aNext;\\nattribute vec2 aPoint;\\nvarying vec2 vPoint;\\nvarying float vLength;\\nuniform float uAspect;\\nuniform float uLwd;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  \\n#ifndef IS_BRUSH\\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\\n  vPosition = mvMatrix * vec4(aPos, 1.);\\n#endif\\n  \\n#ifndef FIXED_QUADS\\n  gl_Position = prMatrix * vPosition;\\n#endif\\n#endif // !IS_BRUSH\\n  \\n#ifdef IS_POINTS\\n  gl_PointSize = POINTSIZE;\\n#endif\\n  \\n  vCol = aCol;\\n  \\n// USE_ENVMAP implies NEEDS_VNORMAL\\n\\n#ifdef NEEDS_VNORMAL\\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\\n#endif\\n\\n#ifdef USE_ENVMAP\\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \\n                        normalize(vNormal.xyz/vNormal.w)));\\n#endif\\n  \\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\n  /* normz should be calculated *after* projection */\\n  normz = (invPrMatrix*vNormal).z;\\n#else\\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\\n#endif\\n#endif // IS_TWOSIDED\\n  \\n#ifdef NEEDS_VNORMAL\\n  vNormal = vec4(normalize(vNormal.xyz), 1);\\n#endif\\n  \\n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\\n  vTexcoord = aTexcoord;\\n#endif\\n  \\n#if defined(FIXED_SIZE) && !defined(ROTATING)\\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w;\\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\\n#endif\\n  \\n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w + vec4(aOfs,  0.);\\n  gl_Position = prMatrix*pos;\\n#endif\\n  \\n#ifdef FAT_LINES\\n  /* This code was inspired by Matt Deslauriers' code in \\n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\\n  vec2 aspectVec = vec2(uAspect, 1.0);\\n  mat4 projViewModel = prMatrix * mvMatrix;\\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\\n  currentProjected = currentProjected/currentProjected.w;\\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\\n  vec2 currentScreen = currentProjected.xy * aspectVec;\\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\\n  float len = uLwd;\\n  vec2 dir = vec2(1.0, 0.0);\\n  vPoint = aPoint;\\n  vLength = length(nextScreen - currentScreen)/2.0;\\n  vLength = vLength/(vLength + len);\\n  if (vLength > 0.0) {\\n    dir = normalize(nextScreen - currentScreen);\\n  }\\n  vec2 normal = vec2(-dir.y, dir.x);\\n  dir.x /= uAspect;\\n  normal.x /= uAspect;\\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\\n  gl_Position = currentProjected + offset;\\n#endif\\n  \\n#ifdef IS_BRUSH\\n  gl_Position = vec4(aPos, 1.);\\n#endif\\n}\",\"fragmentShader\":\"#line 2 2\\n// File 2 is the fragment shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\nvarying vec4 vCol; // carries alpha\\nvarying vec4 vPosition;\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nvarying vec2 vTexcoord;\\nuniform sampler2D uSampler;\\n#endif\\n\\n#ifdef HAS_FOG\\nuniform int uFogMode;\\nuniform vec3 uFogColor;\\nuniform vec4 uFogParms;\\n#endif\\n\\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\\nvarying vec4 vNormal;\\n#endif\\n\\n#if NCLIPPLANES > 0\\nuniform vec4 vClipplane[NCLIPPLANES];\\n#endif\\n\\n#if NLIGHTS > 0\\nuniform mat4 mvMatrix;\\n#endif\\n\\n#ifdef IS_LIT\\nuniform vec3 emission;\\nuniform float shininess;\\n#if NLIGHTS > 0\\nuniform vec3 ambient[NLIGHTS];\\nuniform vec3 specular[NLIGHTS]; // light*material\\nuniform vec3 diffuse[NLIGHTS];\\nuniform vec3 lightDir[NLIGHTS];\\nuniform bool viewpoint[NLIGHTS];\\nuniform bool finite[NLIGHTS];\\n#endif\\n#endif // IS_LIT\\n\\n#ifdef IS_TWOSIDED\\nuniform bool front;\\nvarying float normz;\\n#endif\\n\\n#ifdef FAT_LINES\\nvarying vec2 vPoint;\\nvarying float vLength;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  vec4 fragColor;\\n#ifdef FAT_LINES\\n  vec2 point = vPoint;\\n  bool neg = point.y < 0.0;\\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\\n                 -(point.y - vLength)/(1.0 - vLength);\\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\\n  if (neg && length(point) <= 1.0) discard;\\n#endif\\n  point.y = min(point.y, 0.0);\\n  if (length(point) > 1.0) discard;\\n#endif // FAT_LINES\\n  \\n#ifdef ROUND_POINTS\\n  vec2 coord = gl_PointCoord - vec2(0.5);\\n  if (length(coord) > 0.5) discard;\\n#endif\\n  \\n#if NCLIPPLANES > 0\\n  for (int i = 0; i < NCLIPPLANES; i++)\\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\\n#endif\\n    \\n#ifdef FIXED_QUADS\\n    vec3 n = vec3(0., 0., 1.);\\n#elif defined(IS_LIT)\\n    vec3 n = normalize(vNormal.xyz);\\n#endif\\n    \\n#ifdef IS_TWOSIDED\\n    if ((normz <= 0.) != front) discard;\\n#endif\\n\\n#ifdef IS_LIT\\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\\n    vec3 lightdir;\\n    vec4 colDiff;\\n    vec3 halfVec;\\n    vec4 lighteffect = vec4(emission, 0.);\\n    vec3 col;\\n    float nDotL;\\n#ifdef FIXED_QUADS\\n    n = -faceforward(n, n, eye);\\n#endif\\n    \\n#if NLIGHTS > 0\\n    // Simulate two-sided lighting\\n    if (n.z < 0.0)\\n      n = -n;\\n    for (int i=0;i<NLIGHTS;i++) {\\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\\n      lightdir = lightDir[i];\\n      if (!viewpoint[i]) {\\n        if (finite[i]) {\\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\\n        } else {\\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\\n        }\\n      }\\n      if (!finite[i]) {\\n        halfVec = normalize(lightdir + eye);\\n      } else {\\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\\n        halfVec = normalize(lightdir + eye);\\n      }\\n      col = ambient[i];\\n      nDotL = dot(n, lightdir);\\n      col = col + max(nDotL, 0.) * colDiff.rgb;\\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\\n      lighteffect = lighteffect + vec4(col, colDiff.a);\\n    }\\n#endif\\n    \\n#else // not IS_LIT\\n    vec4 colDiff = vCol;\\n    vec4 lighteffect = colDiff;\\n#endif\\n    \\n#ifdef IS_TEXT\\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\\n#endif\\n    \\n#ifdef HAS_TEXTURE\\n\\n// These calculations use the definitions from \\n// https://docs.gl/gl3/glTexEnv\\n\\n#ifdef USE_ENVMAP\\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\\n#else\\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\\n#endif\\n\\n#ifdef TEXTURE_rgb\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\\n#endif\\n\\n#endif //TEXTURE_rgb\\n        \\n#ifdef TEXTURE_rgba\\n\\n#ifdef TEXMODE_replace\\n// already done\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*textureColor;\\n#endif\\n\\n#ifdef TEXMODE_decal\\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\\n                     textureColor.a*textureColor.rgb, \\n                     lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n    \\n#endif //TEXTURE_rgba\\n    \\n#ifdef TEXTURE_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(lighteffect.rgb, luminance);\\n#endif \\n\\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\\n#endif\\n \\n#endif // TEXTURE_alpha\\n    \\n// The TEXTURE_luminance values are not from that reference    \\n#ifdef TEXTURE_luminance\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#endif // TEXTURE_luminance\\n \\n    \\n#ifdef TEXTURE_luminance_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n\\n#endif\\n\\n#endif // TEXTURE_luminance_alpha\\n    \\n    fragColor = textureColor;\\n\\n#elif defined(IS_TEXT)\\n    if (textureColor.a < 0.1)\\n      discard;\\n    else\\n      fragColor = textureColor;\\n#else\\n    fragColor = lighteffect;\\n#endif // HAS_TEXTURE\\n    \\n#ifdef HAS_FOG\\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\\n    // In Exp and Exp2: use density = density/far\\n    // fogF will be the proportion of fog\\n    // Initialize it to the linear value\\n    float fogF;\\n    if (uFogMode > 0) {\\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\\n      if (uFogMode > 1)\\n        fogF = mix(uFogParms.w, 1.0, fogF);\\n      fogF = fogF*uFogParms.z;\\n      if (uFogMode == 2)\\n        fogF = 1.0 - exp(-fogF);\\n      // Docs are wrong: use (density*c)^2, not density*c^2\\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\\n      else if (uFogMode == 3)\\n        fogF = 1.0 - exp(-fogF*fogF);\\n      fogF = clamp(fogF, 0.0, 1.0);\\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\\n    } else gl_FragColor = fragColor;\\n#else\\n    gl_FragColor = fragColor;\\n#endif // HAS_FOG\\n    \\n}\",\"players\":[],\"webGLoptions\":{\"preserveDrawingBuffer\":true},\"fastTransparency\":true},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n:::\n\n::: column\n$UA$ is collapsed to a 2D plane!\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"rgl97798\" style=\"width:400px;height:400px;\" class=\"rglWebGL html-widget \" role=\"img\" aria-labelledby=\"rgl97798-aria\"></div>\n<script type=\"application/json\" data-for=\"rgl97798\">{\"x\":{\"material\":{\"color\":\"#000000\",\"alpha\":1,\"lit\":true,\"ambient\":\"#000000\",\"specular\":\"#FFFFFF\",\"emission\":\"#000000\",\"shininess\":50,\"smooth\":true,\"front\":\"filled\",\"back\":\"filled\",\"size\":3,\"lwd\":1,\"fog\":true,\"point_antialias\":false,\"line_antialias\":false,\"texture\":null,\"textype\":\"rgb\",\"texmode\":\"modulate\",\"texmipmap\":false,\"texminfilter\":\"linear\",\"texmagfilter\":\"linear\",\"texenvmap\":false,\"depth_mask\":true,\"depth_test\":\"less\",\"isTransparent\":false,\"polygon_offset\":[0,0],\"margin\":\"\",\"floating\":false,\"tag\":\"\",\"blend\":[\"src_alpha\",\"one_minus_src_alpha\"]},\"rootSubscene\":6,\"objects\":{\"25\":{\"id\":25,\"type\":\"points\",\"material\":{\"lit\":false},\"vertices\":\"0\",\"colors\":\"1\",\"centers\":\"2\",\"ignoreExtent\":false,\"flags\":34816},\"27\":{\"id\":27,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":0,\"floating\":true,\"edge\":[0,1,1]},\"vertices\":\"3\",\"colors\":\"4\",\"texts\":[[\"x\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"5\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"28\":{\"id\":28,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":1,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"6\",\"colors\":\"7\",\"texts\":[[\"y\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"8\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"29\":{\"id\":29,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":2,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"9\",\"colors\":\"10\",\"texts\":[[\"z\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"11\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"10\":{\"id\":10,\"type\":\"light\",\"vertices\":[[0,0,1]],\"colors\":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],\"viewpoint\":true,\"finite\":false},\"12\":{\"id\":12,\"type\":\"background\",\"material\":{\"lit\":false,\"back\":\"lines\"},\"colors\":\"12\",\"centers\":\"13\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"26\":{\"id\":26,\"type\":\"bboxdeco\",\"material\":{\"front\":\"lines\",\"back\":\"lines\"},\"vertices\":\"14\",\"colors\":\"15\",\"axes\":{\"mode\":[\"pretty\",\"pretty\",\"pretty\"],\"step\":[1,2,0.5],\"nticks\":[5,5,5],\"marklen\":[15,15,15],\"expand\":[1.029999971389771,1.029999971389771,1.029999971389771]},\"draw_front\":true,\"flags\":32769},\"6\":{\"id\":6,\"type\":\"subscene\",\"par3d\":{\"antialias\":8,\"FOV\":30,\"ignoreExtent\":false,\"listeners\":6,\"mouseMode\":{\"none\":\"none\",\"left\":\"trackball\",\"right\":\"zoom\",\"middle\":\"fov\",\"wheel\":\"pull\"},\"observer\":[0,0,32.66136932373047],\"modelMatrix\":[[1.503504276275635,0,0,-4.450045585632324],[0,0.2192624062299728,2.663821697235107,-5.534337520599365],[0,-0.6024184823036194,0.9695518612861633,-29.79559707641602],[0,0,0,1]],\"projMatrix\":[[3.732050657272339,0,0,0],[0,3.732050657272339,0,0],[0,0,-3.86370325088501,-117.7404556274414],[0,0,-1,0]],\"skipRedraw\":false,\"userMatrix\":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],\"userProjection\":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],\"scale\":[1.503504276275635,0.641080379486084,2.834779977798462],\"viewport\":{\"x\":0,\"y\":0,\"width\":1,\"height\":1},\"zoom\":1,\"bbox\":[0.3970521092414856,5.522512912750244,1.142953038215637,13.16352462768555,0.129585936665535,2.848016500473022],\"windowRect\":[190,213,446,469],\"family\":\"sans\",\"font\":1,\"cex\":1,\"useFreeType\":false,\"fontname\":\"TT Arial\",\"maxClipPlanes\":8,\"glVersion\":4.6,\"activeSubscene\":0},\"embeddings\":{\"viewport\":\"replace\",\"projection\":\"replace\",\"model\":\"replace\",\"mouse\":\"replace\"},\"objects\":[12,26,25,27,28,29,10],\"subscenes\":[],\"flags\":36113}},\"crosstalk\":{\"key\":[],\"group\":[],\"id\":[],\"options\":[]},\"width\":400,\"height\":400,\"buffer\":{\"accessors\":[{\"bufferView\":0,\"componentType\":5126,\"count\":100,\"type\":\"VEC3\"},{\"bufferView\":1,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":2,\"componentType\":5126,\"count\":100,\"type\":\"VEC3\"},{\"bufferView\":3,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":4,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":5,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":6,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":7,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":8,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":9,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":10,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":11,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":12,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":13,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":14,\"componentType\":5126,\"count\":16,\"type\":\"VEC3\"},{\"bufferView\":15,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"}],\"bufferViews\":[{\"buffer\":0,\"byteLength\":1200,\"byteOffset\":0},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":1200},{\"buffer\":0,\"byteLength\":1200,\"byteOffset\":1204},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2404},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2416},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2420},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2432},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2444},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2448},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2460},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2472},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":2476},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2488},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":2492},{\"buffer\":0,\"byteLength\":192,\"byteOffset\":2496},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":2688}],\"buffers\":[{\"byteLength\":2692,\"bytes\":\"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\"}]},\"context\":{\"shiny\":false,\"rmarkdown\":null},\"vertexShader\":\"#line 2 1\\n// File 1 is the vertex shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\n\\nattribute vec3 aPos;\\nattribute vec4 aCol;\\nuniform mat4 mvMatrix;\\nuniform mat4 prMatrix;\\nvarying vec4 vCol;\\nvarying vec4 vPosition;\\n\\n#ifdef NEEDS_VNORMAL\\nattribute vec3 aNorm;\\nuniform mat4 normMatrix;\\nvarying vec4 vNormal;\\n#endif\\n\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nattribute vec2 aTexcoord;\\nvarying vec2 vTexcoord;\\n#endif\\n\\n#ifdef FIXED_SIZE\\nuniform vec3 textScale;\\n#endif\\n\\n#ifdef FIXED_QUADS\\nattribute vec3 aOfs;\\n#endif\\n\\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\nvarying float normz;\\nuniform mat4 invPrMatrix;\\n#else\\nattribute vec3 aPos1;\\nattribute vec3 aPos2;\\nvarying float normz;\\n#endif\\n#endif // IS_TWOSIDED\\n\\n#ifdef FAT_LINES\\nattribute vec3 aNext;\\nattribute vec2 aPoint;\\nvarying vec2 vPoint;\\nvarying float vLength;\\nuniform float uAspect;\\nuniform float uLwd;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  \\n#ifndef IS_BRUSH\\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\\n  vPosition = mvMatrix * vec4(aPos, 1.);\\n#endif\\n  \\n#ifndef FIXED_QUADS\\n  gl_Position = prMatrix * vPosition;\\n#endif\\n#endif // !IS_BRUSH\\n  \\n#ifdef IS_POINTS\\n  gl_PointSize = POINTSIZE;\\n#endif\\n  \\n  vCol = aCol;\\n  \\n// USE_ENVMAP implies NEEDS_VNORMAL\\n\\n#ifdef NEEDS_VNORMAL\\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\\n#endif\\n\\n#ifdef USE_ENVMAP\\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \\n                        normalize(vNormal.xyz/vNormal.w)));\\n#endif\\n  \\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\n  /* normz should be calculated *after* projection */\\n  normz = (invPrMatrix*vNormal).z;\\n#else\\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\\n#endif\\n#endif // IS_TWOSIDED\\n  \\n#ifdef NEEDS_VNORMAL\\n  vNormal = vec4(normalize(vNormal.xyz), 1);\\n#endif\\n  \\n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\\n  vTexcoord = aTexcoord;\\n#endif\\n  \\n#if defined(FIXED_SIZE) && !defined(ROTATING)\\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w;\\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\\n#endif\\n  \\n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w + vec4(aOfs,  0.);\\n  gl_Position = prMatrix*pos;\\n#endif\\n  \\n#ifdef FAT_LINES\\n  /* This code was inspired by Matt Deslauriers' code in \\n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\\n  vec2 aspectVec = vec2(uAspect, 1.0);\\n  mat4 projViewModel = prMatrix * mvMatrix;\\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\\n  currentProjected = currentProjected/currentProjected.w;\\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\\n  vec2 currentScreen = currentProjected.xy * aspectVec;\\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\\n  float len = uLwd;\\n  vec2 dir = vec2(1.0, 0.0);\\n  vPoint = aPoint;\\n  vLength = length(nextScreen - currentScreen)/2.0;\\n  vLength = vLength/(vLength + len);\\n  if (vLength > 0.0) {\\n    dir = normalize(nextScreen - currentScreen);\\n  }\\n  vec2 normal = vec2(-dir.y, dir.x);\\n  dir.x /= uAspect;\\n  normal.x /= uAspect;\\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\\n  gl_Position = currentProjected + offset;\\n#endif\\n  \\n#ifdef IS_BRUSH\\n  gl_Position = vec4(aPos, 1.);\\n#endif\\n}\",\"fragmentShader\":\"#line 2 2\\n// File 2 is the fragment shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\nvarying vec4 vCol; // carries alpha\\nvarying vec4 vPosition;\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nvarying vec2 vTexcoord;\\nuniform sampler2D uSampler;\\n#endif\\n\\n#ifdef HAS_FOG\\nuniform int uFogMode;\\nuniform vec3 uFogColor;\\nuniform vec4 uFogParms;\\n#endif\\n\\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\\nvarying vec4 vNormal;\\n#endif\\n\\n#if NCLIPPLANES > 0\\nuniform vec4 vClipplane[NCLIPPLANES];\\n#endif\\n\\n#if NLIGHTS > 0\\nuniform mat4 mvMatrix;\\n#endif\\n\\n#ifdef IS_LIT\\nuniform vec3 emission;\\nuniform float shininess;\\n#if NLIGHTS > 0\\nuniform vec3 ambient[NLIGHTS];\\nuniform vec3 specular[NLIGHTS]; // light*material\\nuniform vec3 diffuse[NLIGHTS];\\nuniform vec3 lightDir[NLIGHTS];\\nuniform bool viewpoint[NLIGHTS];\\nuniform bool finite[NLIGHTS];\\n#endif\\n#endif // IS_LIT\\n\\n#ifdef IS_TWOSIDED\\nuniform bool front;\\nvarying float normz;\\n#endif\\n\\n#ifdef FAT_LINES\\nvarying vec2 vPoint;\\nvarying float vLength;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  vec4 fragColor;\\n#ifdef FAT_LINES\\n  vec2 point = vPoint;\\n  bool neg = point.y < 0.0;\\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\\n                 -(point.y - vLength)/(1.0 - vLength);\\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\\n  if (neg && length(point) <= 1.0) discard;\\n#endif\\n  point.y = min(point.y, 0.0);\\n  if (length(point) > 1.0) discard;\\n#endif // FAT_LINES\\n  \\n#ifdef ROUND_POINTS\\n  vec2 coord = gl_PointCoord - vec2(0.5);\\n  if (length(coord) > 0.5) discard;\\n#endif\\n  \\n#if NCLIPPLANES > 0\\n  for (int i = 0; i < NCLIPPLANES; i++)\\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\\n#endif\\n    \\n#ifdef FIXED_QUADS\\n    vec3 n = vec3(0., 0., 1.);\\n#elif defined(IS_LIT)\\n    vec3 n = normalize(vNormal.xyz);\\n#endif\\n    \\n#ifdef IS_TWOSIDED\\n    if ((normz <= 0.) != front) discard;\\n#endif\\n\\n#ifdef IS_LIT\\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\\n    vec3 lightdir;\\n    vec4 colDiff;\\n    vec3 halfVec;\\n    vec4 lighteffect = vec4(emission, 0.);\\n    vec3 col;\\n    float nDotL;\\n#ifdef FIXED_QUADS\\n    n = -faceforward(n, n, eye);\\n#endif\\n    \\n#if NLIGHTS > 0\\n    // Simulate two-sided lighting\\n    if (n.z < 0.0)\\n      n = -n;\\n    for (int i=0;i<NLIGHTS;i++) {\\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\\n      lightdir = lightDir[i];\\n      if (!viewpoint[i]) {\\n        if (finite[i]) {\\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\\n        } else {\\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\\n        }\\n      }\\n      if (!finite[i]) {\\n        halfVec = normalize(lightdir + eye);\\n      } else {\\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\\n        halfVec = normalize(lightdir + eye);\\n      }\\n      col = ambient[i];\\n      nDotL = dot(n, lightdir);\\n      col = col + max(nDotL, 0.) * colDiff.rgb;\\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\\n      lighteffect = lighteffect + vec4(col, colDiff.a);\\n    }\\n#endif\\n    \\n#else // not IS_LIT\\n    vec4 colDiff = vCol;\\n    vec4 lighteffect = colDiff;\\n#endif\\n    \\n#ifdef IS_TEXT\\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\\n#endif\\n    \\n#ifdef HAS_TEXTURE\\n\\n// These calculations use the definitions from \\n// https://docs.gl/gl3/glTexEnv\\n\\n#ifdef USE_ENVMAP\\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\\n#else\\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\\n#endif\\n\\n#ifdef TEXTURE_rgb\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\\n#endif\\n\\n#endif //TEXTURE_rgb\\n        \\n#ifdef TEXTURE_rgba\\n\\n#ifdef TEXMODE_replace\\n// already done\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*textureColor;\\n#endif\\n\\n#ifdef TEXMODE_decal\\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\\n                     textureColor.a*textureColor.rgb, \\n                     lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n    \\n#endif //TEXTURE_rgba\\n    \\n#ifdef TEXTURE_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(lighteffect.rgb, luminance);\\n#endif \\n\\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\\n#endif\\n \\n#endif // TEXTURE_alpha\\n    \\n// The TEXTURE_luminance values are not from that reference    \\n#ifdef TEXTURE_luminance\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#endif // TEXTURE_luminance\\n \\n    \\n#ifdef TEXTURE_luminance_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n\\n#endif\\n\\n#endif // TEXTURE_luminance_alpha\\n    \\n    fragColor = textureColor;\\n\\n#elif defined(IS_TEXT)\\n    if (textureColor.a < 0.1)\\n      discard;\\n    else\\n      fragColor = textureColor;\\n#else\\n    fragColor = lighteffect;\\n#endif // HAS_TEXTURE\\n    \\n#ifdef HAS_FOG\\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\\n    // In Exp and Exp2: use density = density/far\\n    // fogF will be the proportion of fog\\n    // Initialize it to the linear value\\n    float fogF;\\n    if (uFogMode > 0) {\\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\\n      if (uFogMode > 1)\\n        fogF = mix(uFogParms.w, 1.0, fogF);\\n      fogF = fogF*uFogParms.z;\\n      if (uFogMode == 2)\\n        fogF = 1.0 - exp(-fogF);\\n      // Docs are wrong: use (density*c)^2, not density*c^2\\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\\n      else if (uFogMode == 3)\\n        fogF = 1.0 - exp(-fogF*fogF);\\n      fogF = clamp(fogF, 0.0, 1.0);\\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\\n    } else gl_FragColor = fragColor;\\n#else\\n    gl_FragColor = fragColor;\\n#endif // HAS_FOG\\n    \\n}\",\"players\":[],\"webGLoptions\":{\"preserveDrawingBuffer\":true},\"fastTransparency\":true},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n:::\n\n## What gives with $A$? \n\n$$A =\\begin{pmatrix} 1 & 4 & 2 \\\\ 2 & 5 & 1 \\\\ 3 & 6 & 0 \\end{pmatrix}$$\n\n. . .\n\n$$= \\begin{pmatrix} 1 & 4 & 4-2\\cdot 1 \\\\ 2 & 5 & 5-2\\cdot2 \\\\ 3 & 6 & 6-2\\cdot 3 \\end{pmatrix}$$\n\n. . .\n\nSo the 3rd column is a *linear combination* of the first two!\n\n## Determinants and rank deficiency {.smaller}\n\n-  A *rank deficient* transformation matrix has redundancy in rows or columns\n- In other words, one or more of the columns is a linear combination of the others (equivalent for rows)\n- A *rank deficient*, $p\\times p$ matrix $A$ has determinant = 0\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    2\n[2,]    2    5    1\n[3,]    3    6    0\n```\n\n\n:::\n\n```{.r .cell-code}\ndet(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n- *Determinant* = scalar-valued function of a square matrix\n\n$$det \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} =ad-bc$$\n- ...increasingly more complex for higher $p$! (use `R` in general)\n\n\n\n## Rank deficiency in 2 dimensions {.smaller}\n\nConsider the $n=50$, $p=2$-dimensional vectors in the `cars` data set:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-24-1.png){fig-align='center' width=288}\n:::\n:::\n\n\n\n## Rank deficiency in 2 dimensions {.smaller}\n\n- Let's apply the $2 \\times 2$ transformation matrix $A = \\begin{pmatrix} 1 &0\\\\ 0&0\\end{pmatrix}$\n- This collapses the data set down to just its $x$ coordinates: \n\n::: {.column width=\"60%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,0,\n              0,0\n              ), \n            nrow = 2, ncol = 2,\n            byrow=TRUE\n            )\ndet(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ncars_transformed <- data.frame(as.matrix(cars) %*% A)\n```\n:::\n\n:::\n\n::: {.column width=\"40%\"} \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-26-1.png){fig-align='center' width=384}\n:::\n:::\n\n:::\n\n## Quiz question 1 \n\nLet $T$ be a transformation matrix represented by:\n\n$$T = \\begin{pmatrix} 1 & 0 \\\\ 2 & -3 \\end{pmatrix}$$\n\nDoes this matrix produce a $2 \\rightarrow 2$ or a $2 \\rightarrow 1$ transformation?\n\nFind the determinant to answer this question!\n\n## Verifying quiz question 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nT <- matrix(c(1, 0, \n              2, -3), \n            nrow = 2, ncol = 2,\n            byrow = TRUE\n            )\nn <- 20\nsomedata <- matrix(runif(n*2), \n                   nrow = n, ncol = 2)\nsomedata_transformed <- somedata %*% T\nplot(somedata, main = 'somedata')\nplot(somedata_transformed, main = 'somedata_transformed')\n```\n:::\n\n\n\n::: column\n\n::: {.cell}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-28-1.png){width=288}\n:::\n:::\n\n:::\n\n::: column\n\n::: {.cell}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-29-1.png){width=288}\n:::\n:::\n\n:::\n\n\n\n## Quiz question 2 \n\nLet $W$ be a transformation matrix represented by:\n\n$$W = \\begin{pmatrix} 1 & 3 \\\\ 2 & 6 \\end{pmatrix}$$\n\nDoes this matrix produce a $2 \\rightarrow 2$ or a $2 \\rightarrow 1$ transformation?  Answer in 2 ways:\n\n- Finding the determinant of the matrix;\n- Identifying in what way the columns are linear combinations of each other\n\n## Verifying quiz question 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nW <- matrix(c(1, 3, \n              2, 6), \n            nrow = 2, ncol = 2,\n            byrow = TRUE\n            )\nsomedata_transformed <- somedata %*% W\n```\n:::\n\n\n\n::: column\n\n::: {.cell}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-31-1.png){width=384}\n:::\n:::\n\n:::\n\n::: column\n\n::: {.cell}\n::: {.cell-output-display}\n![](2---linear-transformations_files/figure-revealjs/unnamed-chunk-32-1.png){width=384}\n:::\n:::\n\n:::\n\n\n\n\n\n\n",
    "supporting": [
      "2---linear-transformations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"2 - linear transformations_files/libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglWebGL-binding-1.3.18/rglWebGL.js\"></script>\n<link href=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/rgl.css\" rel=\"stylesheet\" />\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/rglClass.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/utils.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/buffer.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/subscenes.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/shaders.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/shadersrc.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/textures.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/projection.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/mouse.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/init.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/pieces.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/draw.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/controls.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/selection.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/rglTimer.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/pretty.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/axes.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/rglwidgetClass-1.3.18/animation.src.js\"></script>\n<script src=\"2 - linear transformations_files/libs/CanvasMatrix4-1.3.18/CanvasMatrix.src.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}